import evdev
from evdev import UInput, AbsInfo, ecodes as e, ff
from selectors import DefaultSelector, EVENT_READ
input_names = ["adc-joystick", "adc-keys", "gpio-keys-control", "pwm-vibrator"]

def mainloop():

    # Capabilities, required to describe the virtual device
    caps = {}
    # Using selector API to read from multiple evdev devices
    selector = DefaultSelector()

    rumble = None
    # Find path to evdev devices listed by name
    for path in evdev.list_devices():
        dev = evdev.InputDevice(path) 
        if dev.name not in input_names:
            continue
        # Grabbing gives us exclusive access to this device
        dev.grab()
        # Update capabilities
        for k, v in dev.capabilities().items():
            if k == e.EV_ABS:
                # uinput doesn't allow max lower than min so fix it
                v = fix_absinfo(v)
            if k == e.EV_SYN:
                # EV_SYN is not allowed
                continue
            caps[k] = caps.get(k, []) + v
        selector.register(dev, EVENT_READ)
        if dev.name == "pwm-vibrator":
            rumble = dev

    # Create virtual uinput device
    vdev = UInput(caps, "virt-joypad", version=0x1)
    # Register the uinput device 
    selector.register(vdev, EVENT_READ)

    # Forward all events forever 
    while True:
        for key, _ in selector.select():
            dev = key.fileobj
            
            # Don't forward anything read from the rumble
            if dev.fd == rumble.fd:
                continue
            
            # Handle rumble events written to the virtual uinput device
            if dev.fd == vdev.fd:
                for event in dev.read():
                    
                    # Handle events generated by uinput in reponse to ioctls
                    if event.type == e.EV_UINPUT:

                        if event.code == e.UI_FF_UPLOAD:
                            upload = dev.begin_upload(event.value)
                            
                            # This is some tomfoolery I have to write up later
                            is_new = all(x == 0 for x in bytearray(upload.old))
                            ef = upload.effect
                            id = -1 if is_new else ef.id
                            effect = ff.Effect(ef.type, id, ef.direction,
                                ef.ff_trigger, ef.ff_replay, ef.u)
                            
                            rumble.upload_effect(effect)
                            upload.retval = 0
                            
                            dev.end_upload(upload)
                            dev.syn()    
                            
                        elif event.code == e.UI_FF_ERASE:
                            erase = dev.begin_erase(event.value)
                            rumble.erase_effect(erase.effect_id)
                            erase.retval = 0
                            dev.end_erase(erase)
                            dev.syn()    
                    
                    # Forward writes to actual rumble device. This is why we
                    # aren't reading from rumble, it'll cause a feedback loop.
                    elif event.type == e.EV_FF:
                        rumble.write(event.type, event.code, event.value)

            else:
                for event in dev.read():
                    # Invert these axes to make it work correctly...
                    if event.code == e.ABS_Y or event.code == e.ABS_X: 
                        event.value = invert_absval(event.value)
                    vdev.write(event.type, event.code, event.value)
                    vdev.syn()    

def fix_absinfo(val):
    """
    In the dts for adc-joystick sometimes min is greater than max. 
    This is valid according to adc-joystick schema but uinput doesn't like it.
    """
    return [ (t, AbsInfo(info[0], 15, 1023, info[3], info[4], info[5])) 
        for t, info in val ]

def invert_absval(val):
    return 1008 - (val - 15) + 15

if __name__ == '__main__':
    mainloop()
